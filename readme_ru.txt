Quartus II v13.0 sp1

===Блок внесения сбоев===

Подключается в разрыв между памятью и процессором.


Для корректной работы блока на шине процессора NIOSII реализована следующая логика сигнала ACK (waitrequest_n на шине Avalon)
1. На время сброса сигнал держится в 0
2. При отсутствии обращений к блоку сигнал держится в 1. Это необходимо для того, чтобы не тормозить выполнение программы, если производится обращение к блоку, но с неверным значением индекса.
3. В начале обращения к блоку сигнал падает в 0.
4. В конце цикла обращения (запись памяти при внесении сбоя или чтение памяти при отладочном чтении) сигнал повторяет сигнал ACK от памяти.

Сигналы ACK на интерфейсах памяти имеют такую же полярность.


===Описание аппаратного проекта:===
Простая qsys-система содержит один блок памяти (on-chip memory) размером 2Кб, подключённый в пространство памяти данных процессора через блок внесения сбоев fi_mem_agent. Эта же память дополнительно имеет прямое подключение в пространство памяти данных процессора. 

Разрядность памяти test_memory - 32 бит. Память инициализирована инкрементирующимися на 1 значениями.(*1)
Параметры блока внесения сбоев: iw - 2, index = 2, aw = 9, dw = 32. Последние два параметра соответствуют размеру памяти(*2). 


===Описание программного теста:===
Шаблон проекта - Hello_world_small.
Тест проверяет слудющие функции:
1. Штатное чтение памяти, подключённой через блок внесения сбоев.(*4)
2. Штатная запись памяти, подключённой через блок внесения сбоев.
3. Внесение сбоев в массив памяти по разным адресам с разной маской, с использованием отладочного чтения памяти через блок внесения сбоев.


===Процесс отладки:===
В ходе выполнения программных тестов(*3, *5)
1. Наблюдение сигналов и состояний автомата для агента внесения сбоев в SignalTap.
2. Параллельно - наблюдение за содержимым памяти в In-system Memory COntent Editor.


===Замечания:===
*1. При указании файла инициализации содержимого памяти (Enable non-default initialization file), при подключении в qsys-систему, следует указывать относительный путь. В противном случае, по умолчанию указывается абсолютный путь, неверно сохраняющийся во внутреннем текстовом описании компонента памяти, что отображается в виде предупреждения при компиляции в Quartus - в результате память инициализируется нулевыми значениями.
*2. Разрядность шины адреса для блока внесения сбоев fi_block задаётся слов разрядностью dw. Т.е. если память 32-разрядная размером 2Kб = 2^11, то aw = 9.
*3. В последующем, для проведения отладки следует включить разрешение для SignalTap и опцию для памяти. Также следует перенести программный код, т.к. рабочее пространство хранит абсолютные пути к файлам проектов.
*4. Для доступа к памяти следует объявлять массив через указатель на тип volatile. Например:
	int* volatile test_memory_fi_direct = (int*)FI_AGENT_ORIGINAL_INTERFACE_BASE;
В противном случае из-за оптимизации в программе может быть не видно изменений фактического содержимого памяти.
*5. Для запуска программы в режиме отладки для корректных переходов по коду и отображения значений наблюдаемых переменных следует в настройках проекта в закладке NiosII Project properties выбрать Optimization  - значение off.


===TODO===
2. Отладка внесения сбоев в несколько блоков памяти. - done
3. Нужен ли индекс у блока внесения сбоев? - не нужен, в qsys-системе не посадить два блока на один базовый адрес 
5. Красивый интерфейс блока внесения сбоев для Qsys - файл fi_mem_agent_hw.tcl - done
7. Макросы для работы с блоком - done
9. _sw.tcl с библиотеками - done [set_sw_property min_compatible_hw_version 1.0]
8. Отладка программного управления по прерыванию параллельно с основной программой - done
6. компонент на github - done

4. Как влияет оптимизация программы на наблюдаемость сбоев в памяти?
1. Оптимизация цикла работы блока внесения сбоев